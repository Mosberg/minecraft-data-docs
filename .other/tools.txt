```python
#!/usr/bin/env python3
import collections
import json
from pathlib import Path

from jsonschema import Draft202012Validator, RefResolver, validate
from semantic_hints.block_models import BLOCK_MODEL_HINTS
from semantic_hints.item_models import ITEM_MODEL_HINTS

# ------------------------------------------------------------
# Utility helpers
# ------------------------------------------------------------


def load_json(path: Path):
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def write_json(path: Path, data: dict, pretty=True):
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        if pretty:
            json.dump(data, f, indent=2, ensure_ascii=False)
        else:
            json.dump(data, f)
        f.write("\n")


def list_schema_files(schema_root: Path):
    return sorted(schema_root.rglob("*.schema.json"))


def canonical_order(obj):
    if isinstance(obj, dict):
        return collections.OrderedDict(
            sorted((k, canonical_order(v)) for k, v in obj.items())
        )
    if isinstance(obj, list):
        return [canonical_order(x) for x in obj]
    return obj


# ------------------------------------------------------------
# Generic value generator (fallback)
# ------------------------------------------------------------


def generate_value_for_schema(schema: dict, minimal=False, maximal=False):
    t = schema.get("type")

    if "oneOf" in schema and t == "object":
        subschema_ref = schema["oneOf"][0]
        ref = subschema_ref.get("$ref")
        if ref and ref.startswith("#/$defs/"):
            def_name = ref.split("/")[-1]
            if "$defs" in schema:
                return generate_value_for_schema(
                    schema["$defs"][def_name], minimal=minimal, maximal=maximal
                )
        return {}

    if t == "string":
        enum = schema.get("enum")
        if enum:
            return enum[0] if minimal else enum[-1]
        const = schema.get("const")
        if const is not None:
            return const
        return "" if minimal else "example"

    if t == "integer":
        if minimal:
            return schema.get("minimum", 0)
        if maximal:
            return schema.get("maximum", 42)
        return 1

    if t == "number":
        if minimal:
            return schema.get("minimum", 0.0)
        if maximal:
            return schema.get("maximum", 42.0)
        return 1.5

    if t == "boolean":
        return True

    if t == "array":
        item_schema = schema.get("items", {})
        min_items = schema.get("minItems", 0)
        max_items = schema.get("maxItems")
        if minimal:
            count = min_items if min_items > 0 else 1
        elif maximal and max_items:
            count = max_items
        else:
            count = min_items if min_items > 0 else 1
        return [
            generate_value_for_schema(item_schema, minimal=True) for _ in range(count)
        ]

    if t == "object":
        result = {}
        props = schema.get("properties", {})
        required = schema.get("required", [])

        if minimal:
            for key in required:
                if key in props:
                    result[key] = generate_value_for_schema(props[key], minimal=True)
            return result

        for key, subschema in props.items():
            result[key] = generate_value_for_schema(subschema, minimal=False)
        return result

    return None


# ------------------------------------------------------------
# Domain-specific generators — Block Models
# ------------------------------------------------------------


def generate_block_model_minimal(schema: dict) -> dict:
    return {
        "parent": BLOCK_MODEL_HINTS["parent_defaults"][0],
        "textures": {
            "particle": BLOCK_MODEL_HINTS["default_particle_texture"],
            "all": BLOCK_MODEL_HINTS["default_block_texture"],
        },
        "elements": [
            {
                "from": BLOCK_MODEL_HINTS["element_defaults"]["from"],
                "to": BLOCK_MODEL_HINTS["element_defaults"]["to"],
                "faces": {
                    face: {
                        "texture": BLOCK_MODEL_HINTS["face_defaults"]["texture"],
                        "uv": BLOCK_MODEL_HINTS["face_defaults"]["uv"],
                    }
                    for face in BLOCK_MODEL_HINTS["faces"]
                },
            }
        ],
    }


def generate_block_model_typical(schema: dict) -> dict:
    return {
        "parent": "block/cube",
        "ambientocclusion": True,
        "textures": {
            "particle": "minecraft:block/stone",
            "side": "minecraft:block/stone",
            "top": "minecraft:block/stone",
            "bottom": "minecraft:block/stone",
        },
        "elements": [
            {
                "from": [0, 0, 0],
                "to": [16, 16, 16],
                "rotation": {
                    "origin": [8, 8, 8],
                    "axis": "y",
                    "angle": 45,
                    "rescale": True,
                },
                "shade": True,
                "light_emission": 0,
                "faces": {
                    "north": {"texture": "#side", "uv": [0, 0, 16, 16]},
                    "south": {"texture": "#side"},
                    "east": {"texture": "#side", "cullface": "east"},
                    "west": {"texture": "#side", "cullface": "west"},
                    "up": {"texture": "#top", "rotation": 90},
                    "down": {"texture": "#bottom"},
                },
            }
        ],
        "display": {
            "gui": {
                "rotation": [30, 45, 0],
                "translation": [0, 0, 0],
                "scale": [0.8, 0.8, 0.8],
            }
        },
        "texture_size": [16, 16],
    }


def generate_block_model_maximal(schema: dict) -> dict:
    ex = generate_block_model_typical(schema)
    ex["elements"][0]["light_emission"] = 15
    ex["elements"][0]["shade"] = False
    return ex


# ------------------------------------------------------------
# Domain-specific generators — Item Models
# ------------------------------------------------------------


def generate_item_model_minimal(schema: dict) -> dict:
    return {
        "parent": ITEM_MODEL_HINTS["parent_defaults"]["generated"],
        "textures": {"layer0": ITEM_MODEL_HINTS["default_item_texture"]},
    }


def generate_item_model_typical(schema: dict) -> dict:
    return {
        "parent": ITEM_MODEL_HINTS["parent_defaults"]["handheld"],
        "textures": {"layer0": "minecraft:item/iron_sword"},
        "display": {
            "thirdperson_righthand": {
                "rotation": [0, -90, 55],
                "translation": [0, 4, 0],
                "scale": [0.85, 0.85, 0.85],
            },
            "firstperson_righthand": {
                "rotation": [0, -90, 25],
                "translation": [1.13, 3.2, 1.13],
                "scale": [0.68, 0.68, 0.68],
            },
        },
    }


def generate_item_model_maximal(schema: dict) -> dict:
    ex = generate_item_model_typical(schema)
    ex["overrides"] = [
        {
            "predicate": {"custom_model_data": 1},
            "model": "minecraft:item/iron_sword_custom",
        }
    ]
    return ex


# ------------------------------------------------------------
# Domain-specific generators — NBT
# ------------------------------------------------------------


def generate_nbt_minimal(schema: dict, schema_path: Path) -> dict:
    name = schema_path.name
    if "item_nbt" in name:
        return {"id": "minecraft:stone", "Count": 1}
    if "block_nbt" in name:
        return {"Name": "minecraft:stone"}
    if "entity_nbt" in name:
        return {"id": "minecraft:zombie"}
    if "armor_stand_nbt" in name:
        return {"id": "minecraft:armor_stand", "Rotation": [0.0, 0.0]}
    if "potion_nbt" in name:
        return {"Potion": "minecraft:water"}
    if "spawner_nbt" in name:
        return {"id": "minecraft:zombie"}
    if "item_frame_nbt" in name:
        return {"id": "minecraft:item_frame"}
    if "falling_block_nbt" in name:
        return {"id": "minecraft:sand"}
    if "villager_nbt" in name:
        return {"id": "minecraft:villager"}
    if "turtle_nbt" in name:
        return {"id": "minecraft:turtle"}
    return {"id": "minecraft:stone"}


def generate_nbt_typical(schema: dict, schema_path: Path) -> dict:
    name = schema_path.name
    if "item_nbt" in name:
        return {
            "id": "minecraft:stone",
            "Count": 64,
            "tag": {"display": {"Name": '{"text":"Example Stone","italic":false}'}},
        }
    if "entity_nbt" in name:
        return {
            "id": "minecraft:zombie",
            "CustomName": '{"text":"Example Zombie"}',
            "Health": 20.0,
            "Passengers": [{"id": "minecraft:chicken"}],
        }
    if "armor_stand_nbt" in name:
        return {
            "id": "minecraft:armor_stand",
            "Invisible": 1,
            "NoGravity": 1,
            "Rotation": [0.0, 0.0],
            "ArmorItems": [
                {"id": "minecraft:diamond_helmet", "Count": 1},
                {"id": "minecraft:diamond_chestplate", "Count": 1},
                {"id": "minecraft:diamond_leggings", "Count": 1},
                {"id": "minecraft:diamond_boots", "Count": 1},
            ],
        }
    return generate_nbt_minimal(schema, schema_path)


def generate_nbt_maximal(schema: dict, schema_path: Path) -> dict:
    ex = generate_nbt_typical(schema, schema_path)
    if "item_nbt" in schema_path.name:
        ex["tag"]["Enchantments"] = [{"id": "minecraft:unbreaking", "lvl": 3}]
    return ex


# ------------------------------------------------------------
# Edge-case examples (generic but slightly semantic)
# ------------------------------------------------------------


def generate_edge_case_examples(schema: dict, schema_path: Path):
    examples = []
    props = schema.get("properties", {})
    required = schema.get("required", [])

    for key, subschema in props.items():
        if "type" not in subschema:
            continue
        t = subschema["type"]
        if t == "string":
            ex1 = {key: ""}
            ex2 = {key: "x" * 256}
            if "id" in required and key != "id":
                ex1["id"] = "minecraft:stone"
                ex2["id"] = "minecraft:stone"
            examples.append(ex1)
            examples.append(ex2)
        elif t == "integer":
            ex1 = {key: subschema.get("minimum", -999999)}
            ex2 = {key: subschema.get("maximum", 999999)}
            if "id" in required and key != "id":
                ex1["id"] = "minecraft:stone"
                ex2["id"] = "minecraft:stone"
            examples.append(ex1)
            examples.append(ex2)
        elif t == "boolean":
            ex1 = {key: True}
            ex2 = {key: False}
            if "id" in required and key != "id":
                ex1["id"] = "minecraft:stone"
                ex2["id"] = "minecraft:stone"
            examples.append(ex1)
            examples.append(ex2)

    return examples


# ------------------------------------------------------------
# Example type dispatcher
# ------------------------------------------------------------


def generate_examples_for_schema(
    schema_path: Path, spec: dict, output_root: Path, example_types=None
):
    schema = load_json(schema_path)
    schema_name = schema_path.stem.replace(".schema", "")
    schema_output_dir = output_root / schema_name

    resolver = RefResolver(base_uri=schema_path.as_uri(), referrer=schema)
    validator = Draft202012Validator(schema, resolver=resolver)

    def validate_example(name, data):
        try:
            validator.validate(data)
        except Exception as e:
            print(
                f"[ERROR] Example '{name}' failed validation for schema {schema_name}: {e}"
            )
            return False
        return True

    if example_types is None:
        example_types = spec["rules"]["generation"]["example_types"]

    is_block_model = "block_model.schema.json" in str(schema_path)
    is_item_model = "item_model.schema.json" in str(schema_path)
    is_nbt = "/nbt/" in str(schema_path).replace("\\", "/")

    generators = {}

    if is_block_model:
        generators = {
            "minimal": lambda: generate_block_model_minimal(schema),
            "typical": lambda: generate_block_model_typical(schema),
            "full": lambda: generate_block_model_maximal(schema),
            "maximal": lambda: generate_block_model_maximal(schema),
            "thematic": lambda: generate_block_model_typical(schema),
            "performance": lambda: generate_block_model_maximal(schema),
            "experimental": lambda: generate_block_model_maximal(schema),
            "vanilla": lambda: generate_block_model_typical(schema),
            "modded": lambda: generate_block_model_typical(schema),
        }
    elif is_item_model:
        generators = {
            "minimal": lambda: generate_item_model_minimal(schema),
            "typical": lambda: generate_item_model_typical(schema),
            "full": lambda: generate_item_model_maximal(schema),
            "maximal": lambda: generate_item_model_maximal(schema),
            "thematic": lambda: generate_item_model_typical(schema),
            "performance": lambda: generate_item_model_maximal(schema),
            "experimental": lambda: generate_item_model_maximal(schema),
            "vanilla": lambda: generate_item_model_typical(schema),
            "modded": lambda: generate_item_model_maximal(schema),
        }
    elif is_nbt:
        generators = {
            "minimal": lambda: generate_nbt_minimal(schema, schema_path),
            "typical": lambda: generate_nbt_typical(schema, schema_path),
            "full": lambda: generate_nbt_maximal(schema, schema_path),
            "maximal": lambda: generate_nbt_maximal(schema, schema_path),
            "thematic": lambda: generate_nbt_typical(schema, schema_path),
            "performance": lambda: generate_nbt_maximal(schema, schema_path),
            "experimental": lambda: generate_nbt_maximal(schema, schema_path),
            "vanilla": lambda: generate_nbt_typical(schema, schema_path),
            "modded": lambda: generate_nbt_maximal(schema, schema_path),
        }
    else:
        generators = {
            "minimal": lambda: generate_value_for_schema(schema, minimal=True),
            "typical": lambda: generate_value_for_schema(schema, minimal=False),
            "full": lambda: generate_value_for_schema(
                schema, minimal=False, maximal=True
            ),
            "maximal": lambda: generate_value_for_schema(
                schema, minimal=False, maximal=True
            ),
            "thematic": lambda: generate_value_for_schema(schema, minimal=False),
            "performance": lambda: generate_value_for_schema(
                schema, minimal=False, maximal=True
            ),
            "experimental": lambda: generate_value_for_schema(
                schema, minimal=False, maximal=True
            ),
            "vanilla": lambda: generate_value_for_schema(schema, minimal=False),
            "modded": lambda: generate_value_for_schema(
                schema, minimal=False, maximal=True
            ),
        }

    for ex_type in example_types:
        if ex_type == "edge_cases":
            edge_dir = schema_output_dir / "edge_cases"
            edge_dir.mkdir(parents=True, exist_ok=True)
            edge_cases = generate_edge_case_examples(schema, schema_path)
            for idx, ex in enumerate(edge_cases):
                ex = canonical_order(ex)
                if validate_example(f"edge-case-{idx+1}", ex):
                    out_path = edge_dir / f"edge-case-{idx+1}.json"
                    write_json(out_path, ex, pretty=True)
                    print(f"[OK] Wrote {out_path}")
        else:
            gen = generators.get(ex_type)
            if gen:
                ex = canonical_order(gen())
                if validate_example(ex_type, ex):
                    out_path = schema_output_dir / f"{ex_type}.json"
                    write_json(out_path, ex, pretty=True)
                    print(f"[OK] Wrote {out_path}")


# ------------------------------------------------------------
# Entry point
# ------------------------------------------------------------


def main():
    root = Path(__file__).resolve().parents[1]
    spec_path = root / "generate-example-json-files.json"
    spec_schema_path = (
        root / "schemas/generator/generate-example-json-files.schema.json"
    )

    spec = load_json(spec_path)
    spec_schema = load_json(spec_schema_path)

    validate(instance=spec, schema=spec_schema)

    schema_root = root / spec["input"]["schema_root"]
    output_root = root / spec["output"]["root"]

    schema_files = list_schema_files(schema_root)

    print(f"Found {len(schema_files)} schema files")

    example_types = spec["rules"]["generation"]["example_types"]

    for schema_path in schema_files:
        print(f"Generating examples for {schema_path}")
        generate_examples_for_schema(
            schema_path, spec, output_root, example_types=example_types
        )

    print("Done.")


if __name__ == "__main__":
    main()

```

```python
#!/usr/bin/env python3
import re
from pathlib import Path


def kebab_to_snake(name: str) -> str:
    return name.replace("-", "_")


def main():
    root = Path(__file__).resolve().parents[1]
    docs_root = root / "docs"
    schemas_root = root / "schemas"

    # Map docs -> expected schema names
    doc_files = sorted(docs_root.glob("*.md"))
    nbt_docs = sorted((docs_root / "nbt").glob("*.md"))

    all_docs = doc_files + nbt_docs

    expected_schemas = set()
    for doc in all_docs:
        base = doc.stem  # e.g. block-models, armor-stand-nbt
        snake = kebab_to_snake(base)
        # Heuristic: strip trailing "-nbt" for NBT docs to match schema naming
        snake = snake.replace("_nbt", "") if "nbt" in doc.parts else snake
        expected_schemas.add(snake)

    schema_files = sorted(schemas_root.rglob("*.schema.json"))
    schema_names = {p.stem.replace(".schema", "") for p in schema_files}

    missing_schemas = sorted(expected_schemas - schema_names)
    orphan_schemas = sorted(schema_names - expected_schemas)

    errors = []

    if missing_schemas:
        errors.append(
            "[ERROR] Docs with no matching schema (by naming convention): "
            + ", ".join(missing_schemas)
        )

    if orphan_schemas:
        # Allow generator schemas to be orphans by design
        orphan_schemas = [s for s in orphan_schemas if not s.startswith("generate")]
        if orphan_schemas:
            errors.append(
                "[ERROR] Schemas with no matching doc (by naming convention): "
                + ", ".join(orphan_schemas)
            )

    # Optional: simple field presence check for top-level headings like "### **field**"
    field_pattern = re.compile(r"^###\s+\*\*(.+?)\*\*", re.MULTILINE)

    for doc in all_docs:
        text = doc.read_text(encoding="utf-8")
        fields = field_pattern.findall(text)
        if not fields:
            continue

        base = doc.stem
        snake = kebab_to_snake(base)
        snake = snake.replace("_nbt", "") if "nbt" in doc.parts else snake

        # Find matching schema
        candidates = [p for p in schema_files if p.stem.startswith(snake)]
        if not candidates:
            continue

        # Just pick the first matching schema
        schema_path = candidates[0]
        import json

        schema = json.loads(schema_path.read_text(encoding="utf-8"))
        props = set(schema.get("properties", {}).keys())

        missing_fields = [f for f in fields if f in props or f.lower() in props]
        # This is intentionally soft; you can tighten it later if you want.

    if errors:
        print("\nDocs–schema lint errors:")
        for e in errors:
            print(e)
        raise SystemExit(1)

    print("Docs and schemas are structurally consistent (naming + basic coverage).")


if __name__ == "__main__":
    main()

```

```python
#!/usr/bin/env python3
import json
from pathlib import Path


def main():
    root = Path(__file__).resolve().parents[1]
    schemas_root = root / "schemas"
    examples_root = root / "examples"
    spec_path = root / "generate-example-json-files.json"

    spec = json.loads(spec_path.read_text(encoding="utf-8"))
    expected_types = spec["rules"]["generation"]["example_types"]

    schema_files = sorted(schemas_root.rglob("*.schema.json"))
    schema_names = [p.stem.replace(".schema", "") for p in schema_files]

    print("# Schema Coverage Report\n")

    for schema_name in schema_names:
        schema_examples_dir = examples_root / schema_name
        print(f"## {schema_name}")

        if not schema_examples_dir.exists():
            print("- Status: ❌ No examples directory found")
            print()
            continue

        # Collect example files
        existing_types = set()
        for path in schema_examples_dir.rglob("*.json"):
            rel = path.relative_to(schema_examples_dir)
            if rel.parts[0] == "edge_cases":
                existing_types.add("edge_cases")
            else:
                existing_types.add(path.stem)

        missing = [t for t in expected_types if t not in existing_types]
        present = [t for t in expected_types if t in existing_types]

        print(f"- Present types: {', '.join(present) if present else 'none'}")
        print(f"- Missing types: {', '.join(missing) if missing else 'none'}")
        print()

```

```python
#!/usr/bin/env python3
from pathlib import Path


def main():
    root = Path(__file__).resolve().parents[1]
    examples_root = root / "examples"

    domains = {
        "block_model": ["minimal", "typical", "maximal"],
        "item_model": ["minimal", "typical", "maximal"],
        "nbt/item_nbt": ["minimal", "typical", "maximal"],
        "nbt/entity_nbt": ["minimal", "typical", "maximal"],
    }

    print("# Semantic Schema Coverage Report\n")

    for key, types in domains.items():
        if "/" in key:
            folder, name = key.split("/")
            schema_name = name
            ex_dir = examples_root / schema_name
        else:
            schema_name = key
            ex_dir = examples_root / schema_name

        print(f"## {schema_name}")

        if not ex_dir.exists():
            print("- Status: ❌ No examples directory found")
            print()
            continue

        present = []
        missing = []

        for t in types:
            path = ex_dir / f"{t}.json"
            if path.exists():
                present.append(t)
            else:
                missing.append(t)

        print(f"- Present semantic types: {', '.join(present) if present else 'none'}")
        print(f"- Missing semantic types: {', '.join(missing) if missing else 'none'}")
        print()


if __name__ == "__main__":
    main()

```

```python
#!/usr/bin/env python3
import json
from pathlib import Path

from jsonschema import Draft202012Validator, RefResolver


def load_json(path: Path):
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def list_schema_files(schema_root: Path):
    return sorted(schema_root.rglob("*.schema.json"))


def list_example_files(examples_root: Path):
    return sorted(examples_root.rglob("*.json"))


def main():
    root = Path(__file__).resolve().parents[1]

    schema_root = root / "schemas"
    examples_root = root / "examples"

    schema_files = list_schema_files(schema_root)
    schema_by_name = {p.stem.replace(".schema", ""): p for p in schema_files}

    example_files = list_example_files(examples_root)

    errors = []

    for ex_path in example_files:
        # examples/<schema-name>/<example-name>.json
        try:
            schema_name = ex_path.relative_to(examples_root).parts[0]
        except Exception:
            errors.append(f"[ERROR] Example outside expected structure: {ex_path}")
            continue

        schema_path = schema_by_name.get(schema_name)
        if not schema_path:
            errors.append(
                f"[ERROR] No schema found for example '{ex_path}' (expected schema name '{schema_name}')"
            )
            continue

        schema = load_json(schema_path)
        instance = load_json(ex_path)

        resolver = RefResolver(base_uri=schema_path.as_uri(), referrer=schema)
        validator = Draft202012Validator(schema, resolver=resolver)

        try:
            validator.validate(instance)
            print(f"[OK] {ex_path} validates against {schema_path.name}")
        except Exception as e:
            errors.append(
                f"[ERROR] Validation failed for {ex_path} against {schema_path.name}: {e}"
            )

    if errors:
        print("\nValidation errors:")
        for e in errors:
            print(e)
        raise SystemExit(1)

    print("All examples validate against their schemas.")


if __name__ == "__main__":
    main()

```

```python
import json
from pathlib import Path


from tools.generateExampleJsonFiles import (
    generate_block_model_minimal,
    generate_block_model_typical,
    generate_item_model_minimal,
    generate_item_model_typical,
    generate_nbt_minimal,
    generate_nbt_typical,
)

ROOT = Path(__file__).resolve().parents[2]


def load_schema(name: str) -> dict:
    path = next((ROOT / "schemas").rglob(name))
    return json.loads(path.read_text(encoding="utf-8"))


def test_block_model_minimal_semantics():
    schema = load_schema("block_model.schema.json")
    ex = generate_block_model_minimal(schema)
    assert ex["parent"] in ["block/cube_all", "block/cube"]
    assert "textures" in ex
    assert "elements" in ex
    assert len(ex["elements"]) == 1
    elem = ex["elements"][0]
    assert elem["from"] == [0, 0, 0]
    assert elem["to"] == [16, 16, 16]


def test_block_model_typical_semantics():
    schema = load_schema("block_model.schema.json")
    ex = generate_block_model_typical(schema)
    assert ex["textures"]["particle"].startswith("minecraft:block/")
    assert "display" in ex
    assert "gui" in ex["display"]


def test_item_model_minimal_semantics():
    schema = load_schema("item_model.schema.json")
    ex = generate_item_model_minimal(schema)
    assert ex["parent"] in ["item/generated", "item/handheld"]
    assert "textures" in ex
    assert "layer0" in ex["textures"]


def test_item_model_typical_semantics():
    schema = load_schema("item_model.schema.json")
    ex = generate_item_model_typical(schema)
    assert ex["textures"]["layer0"].startswith("minecraft:item/")
    assert "display" in ex


def test_nbt_minimal_semantics_item():
    schema = load_schema("item_nbt.schema.json")
    path = next((ROOT / "schemas/nbt").rglob("item_nbt.schema.json"))
    ex = generate_nbt_minimal(schema, path)
    assert ex["id"].startswith("minecraft:")
    assert "Count" in ex


def test_nbt_typical_semantics_entity():
    schema = load_schema("entity_nbt.schema.json")
    path = next((ROOT / "schemas/nbt").rglob("entity_nbt.schema.json"))
    ex = generate_nbt_typical(schema, path)
    assert ex["id"].startswith("minecraft:")
    assert "Passengers" in ex or "CustomName" in ex

```

```python
# Empty on purpose; used to mark this as a package.

```

```python
BLOCK_MODEL_HINTS = {
    "default_block_texture": "minecraft:block/stone",
    "default_particle_texture": "minecraft:block/stone",
    "parent_defaults": ["block/cube_all", "block/cube", "block/orientable"],
    "element_defaults": {"from": [0, 0, 0], "to": [16, 16, 16]},
    "face_defaults": {"texture": "#all", "uv": [0, 0, 16, 16]},
    "faces": ["north", "south", "east", "west", "up", "down"],
}

```

```python
BLOCK_STATE_HINTS = {
    "default_variant": {
        "model": "minecraft:block/stone",
    },
    "multipart_defaults": {
        "apply": {
            "model": "minecraft:block/stone",
        },
    },
    "variant_defaults": {
        "model": "minecraft:block/stone",
    },
}

```

```python
ITEM_MODEL_HINTS = {
    "default_item_texture": "minecraft:item/iron_ingot",
    "parent_defaults": {"generated": "item/generated", "handheld": "item/handheld"},
}

```

```python
NBT_HINTS = {
    "default_item_id": "minecraft:stone",
    "default_entity_id": "minecraft:zombie",
    "default_block_name": "minecraft:stone",
    "default_potion_id": "minecraft:water",
    "default_armor_stand_id": "minecraft:armor_stand",
    "default_item_frame_id": "minecraft:item_frame",
    "default_falling_block_id": "minecraft:sand",
    "default_villager_id": "minecraft:villager",
    "default_turtle_id": "minecraft:turtle",
}

```

```json
{
  "version": "1.0.0",
  "description": "Specification for generating example JSON files from schemas and documentation.",
  "input": {
    "schema_root": "minecraft-data-docs/schemas/",
    "docs_root": "minecraft-data-docs/docs/",
    "validation_settings": "minecraft-data-docs/.vscode/settings.json"
  },
  "rules": {
    "authority": {
      "schemas_are_source_of_truth": true,
      "docs_are_reference_only": true
    },
    "generation": {
      "examples_per_schema": "comprehensive",
      "example_types": [
        "minimal",
        "typical",
        "full",
        "maximal",
        "thematic",
        "performance",
        "experimental",
        "vanilla",
        "modded",
        "edge_cases"
      ],
      "field_ordering": "canonical",
      "naming_convention": "kebab-case",
      "deterministic_output": true,
      "allow_additional_properties": false
    },
    "validation": {
      "strict_schema_validation": true,
      "use_vscode_settings": true,
      "reject_invalid_examples": true
    }
  },
  "output": {
    "root": "minecraft-data-docs/examples/",
    "structure": "minecraft-data-docs/examples/<schema-name>/<example-name>.json",
    "overwrite_existing": true,
    "pretty_print": true,
    "newline_at_end_of_file": true
  },
  "ci_requirements": {
    "fail_on_missing_examples": true,
    "fail_on_invalid_examples": true,
    "fail_on_unexpected_files": true
  }
}
```

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://raw.githubusercontent.com/Mosberg/minecraft-data-docs/main/schemas/generator/generate-example-json-files.schema.json",
  "title": "Example Generator Specification",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "version": { "type": "string" },
    "description": { "type": "string" },
    "input": {
      "type": "object",
      "additionalProperties": false,
      "required": ["schema_root", "docs_root", "validation_settings"],
      "properties": {
        "schema_root": { "type": "string" },
        "docs_root": { "type": "string" },
        "validation_settings": { "type": "string" }
      }
    },
    "rules": {
      "type": "object",
      "additionalProperties": false,
      "required": ["authority", "generation", "validation"],
      "properties": {
        "authority": {
          "type": "object",
          "additionalProperties": false,
          "required": ["schemas_are_source_of_truth", "docs_are_reference_only"],
          "properties": {
            "schemas_are_source_of_truth": { "type": "boolean" },
            "docs_are_reference_only": { "type": "boolean" }
          }
        },
        "generation": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "examples_per_schema",
            "example_types",
            "field_ordering",
            "naming_convention",
            "deterministic_output",
            "allow_additional_properties"
          ],
          "properties": {
            "examples_per_schema": {
              "type": "string",
              "enum": ["comprehensive"]
            },
            "example_types": {
              "type": "array",
              "minItems": 1,
              "uniqueItems": true,
              "items": {
                "type": "string",
                "enum": [
                  "minimal",
                  "typical",
                  "full",
                  "maximal",
                  "thematic",
                  "performance",
                  "experimental",
                  "vanilla",
                  "modded",
                  "edge_cases"
                ]
              }
            },
            "field_ordering": {
              "type": "string",
              "enum": ["canonical"]
            },
            "naming_convention": {
              "type": "string",
              "enum": ["kebab-case"]
            },
            "deterministic_output": { "type": "boolean" },
            "allow_additional_properties": { "type": "boolean" }
          }
        },
        "validation": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "strict_schema_validation",
            "use_vscode_settings",
            "reject_invalid_examples"
          ],
          "properties": {
            "strict_schema_validation": { "type": "boolean" },
            "use_vscode_settings": { "type": "boolean" },
            "reject_invalid_examples": { "type": "boolean" }
          }
        }
      }
    },
    "output": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "root",
        "structure",
        "overwrite_existing",
        "pretty_print",
        "newline_at_end_of_file"
      ],
      "properties": {
        "root": { "type": "string" },
        "structure": { "type": "string" },
        "overwrite_existing": { "type": "boolean" },
        "pretty_print": { "type": "boolean" },
        "newline_at_end_of_file": { "type": "boolean" }
      }
    },
    "ci_requirements": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "fail_on_missing_examples",
        "fail_on_invalid_examples",
        "fail_on_unexpected_files"
      ],
      "properties": {
        "fail_on_missing_examples": { "type": "boolean" },
        "fail_on_invalid_examples": { "type": "boolean" },
        "fail_on_unexpected_files": { "type": "boolean" }
      }
    }
  },
  "required": ["version", "description", "input", "rules", "output", "ci_requirements"]
}
```
